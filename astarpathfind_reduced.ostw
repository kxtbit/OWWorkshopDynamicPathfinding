/*
 * Overwatch Workshop Dynamic Pathfinding
 * made by kxtbit#1903 (battle.net / workshop.codes)
 * originally uploaded at https://github.com/kxtbit/OWWorkshopDynamicPathfinding/blob/main/astarpathfind_reduced.ostw
 * please credit me if you use this for your stuff, also LGPLv3 and stuff cool bye
 */

//macro that checks line of sight between cells
//uses RayCastHitPosition instead of IsInLineOfSight because there was some weird inaccuracies with the latter
Boolean pathfindLOSCheck(Vector pos, Vector dir): RayCastHitPosition(pos, pos + dir, null, null, false) == pos + dir;
//line of sight check for the overlayed grid thingy
Boolean flatLOSCheck(Vector pos, Vector dir):
    pathfindLOSCheck(pos, dir + Vector(0, 0.25, 0));
//macro to get the correct grid position for a neighbor using the overlayed grid thingy
Vector moveGridPos(Vector rootPos, Vector pos, Vector dir):
    RayCastHitPosition(pos + dir + Vector(0, 0.25, 0), pos + dir + Vector(0, -9999, 0), null, null, false) - rootPos + Vector(0, 1, 0);
//gets the neighbor nodes of a node
Any[][] getNeighbors(Any[] node, Vector firstPos, Vector lastPos) {
    Any[][] neighbors = [];
    Vector rootPos = node[0];
    Vector gridPos = node[1];
    Vector pos = rootPos + gridPos;
    foreach (Vector dir in [Forward(), Right(), Backward(), Left(), Backward() + Left(), Left() + Forward(), Forward() + Right(), Right() + Backward()]) {
        if (flatLOSCheck(pos, dir * 1.5)) {
            //neighbors.ModAppend(scan(rootPos, gridPos, dir.X, dir.Z, 1.5, lastPos));
            //neighbors.ModAppend([[rootPos, gridPos + dir * 2, 1]]);
            neighbors.ModAppend([[rootPos, moveGridPos(rootPos, pos, dir * 1.5), 1]]);
        }
    }
    return neighbors;
}

//adds a node to a priority queue
void priorityQueueAdd(ref Any[][] list, ref Any[] obj, ref Boolean listSorted) {
    list.ModAppend([obj]);
    listSorted = false;
}
globalvar Number antiCrashCounter = 0;
//removes the lowest priority node from a priority queue
Any[] priorityQueueRemove(ref Any[][] list, Number waitThreshold, ref Boolean listSorted) {
    if (antiCrashCounter >= waitThreshold) {
        Wait(0.016);
        antiCrashCounter = 0;
    }
    //if the list is already sorted, don't sort it again
    if (!listSorted) {
        list = SortedArray(list, ArrayElement()[2]);
        listSorted = true;
    }
    antiCrashCounter += list.Length * 0.08;
    Any[] value = list[0];
    list.ModRemoveByIndex(0);
    return value;
}

//gets the dual index for a key in a dual index dictionary
Number[] getDualIndex(ref Any[][] dArray, ref Any value) {
    Number[] mapped = MappedArray(dArray, IndexOfArrayValue(ArrayElement(), value));
    Number[] ret;
    for (Number i = 0; i < mapped.Length; i++) {
        if (mapped[i] != -1) {
            ret = [i, mapped[i]];
            break;
        }
    }
    if (ret == null) ret = [];
    return ret;
}

//stores references to all debug effects
globalvar Any[] vizEffects = [];

//pathfinding heuristic function
Number heuristic(Vector lastPos, Vector pos): DistanceBetween(lastPos, pos) * 1.005;

//multi use variables for pathfind function
globalvar Number i1;
globalvar Number i2;
globalvar Boolean check;
globalvar Number newCost;
globalvar Number[] dualIndex;
globalvar Boolean costCheck;
globalvar Number[] dualIndex2;
//the pathfinder itself. firstPos is the starting position, and lastPos is the goal position.
//if refinePath is off, it disables the path refiner, which causes more steps to be in the resulting path
//and also may make it longer, but can fix some issues with certain maps
//nodeLimit sets the amount of nodes generated that will cause the algorithm to fail
//(to prevent pathfinding from taking too long or crashing the server)
//forceAlgorithm changes the pathfinding algorithm used. 0 is automatic, 1 is A*, and 2 is Greedy Best First Search
//waitThreshhold controls when the algorithm will wait to reduce server load. on the default setting of 10, it will be fairly fast
//but will probably also max out or close to max out the server lode when pathfinding. values above 15 are in danger of crashing the server quickly,
//and values below 5 will cause the algorithm to be slow.

//the function returns a list of vectors containing each point in the path that was found, or an empty array if no path was found.
public Vector[] pathfind(Vector firstPos, Vector lastPos, Boolean refinePath = true, Number nodeLimit = 1500, Number forceAlgorithm = 0, Number waitThreshold = 10) {
    //uncomment this to enable debug visualization (2 more below)
    //DestroyEffect(vizEffects);
    //vizEffects = [];
    Boolean listSorted = false;
    Boolean useAStar = forceAlgorithm == 0 ? (DistanceBetween(firstPos, lastPos) <= 75) : (forceAlgorithm == 1);

    Any[][] frontier = [];
    Any[] first = [firstPos, Vector(0, 0, 0), 0];
    Vector[] valKeys = [first[1]];
    Number[] costsValues = [0];
    Any[][] parentsValues = [null];
    antiCrashCounter = 0;

    Boolean useDualIndex = false;

    priorityQueueAdd(frontier, first, listSorted);
    while (frontier.Length != 0) {
        Any[] current = priorityQueueRemove(frontier, waitThreshold, listSorted);
        Number i;
        if (nodeLimit != -1) {
            if (dualIndex) {
                Number length = 0;
                for (i = 0; valKeys.Length; i++) {
                    length += CountOf(valKeys[i]);
                }
                if (length > nodeLimit) return [];
            } else {
                if (valKeys.Length > nodeLimit) return [];
            }
        }
        if (DistanceBetween(current[0] + current[1], lastPos) <= 1.5 && IsInLineOfSight(lastPos, current[0] + current[1])) {
            Vector[] finalPath = [lastPos];
            Any[] node = current;
            while (node != null) {
                finalPath = InsertValueInArray(finalPath, 0, node[0] + node[1]);
                if (useDualIndex) {
                    define dualIndex = getDualIndex(valKeys, node[1]);
                    node = parentsValues[dualIndex[0]][dualIndex[1]];
                } else
                    node = parentsValues[valKeys.IndexOf(node[1])];
            }
            Vector[] finalPathRefined;
            if (refinePath) {
                finalPathRefined = [finalPath[0]];
                for (i = 0; finalPath.Length; 1) {
                    Vector pos = finalPath[i];
                    for (Number n = finalPath.Length-1; i; -1) {
                        Vector checkPos = finalPath[n];
                        if (RayCastHitPosition(pos, checkPos, null, null, false) == checkPos && checkPos.Y - pos.Y < 1) {
                            Boolean noHole = true;
                            for (Number v = 0; 5; 1) {
                                Vector lerpPos = LinearInterpolate(pos, checkPos, v / 5);
                                if (RayCastHitPosition(lerpPos, lerpPos + Vector(0, -2, 0), null, null, false) == lerpPos + Vector(0, -2, 0)) {
                                    noHole = false;
                                    break;
                                }
                            }
                            if (noHole) {
                                finalPathRefined.ModAppend(checkPos);
                                i = n-1;
                                break;
                            }
                        }
                    }
                }
            } else {
                finalPathRefined = finalPath;
            }
            return finalPathRefined;
        }
        Any[][] neighbors = getNeighbors(current, firstPos, lastPos);
        for (i = 0; neighbors.Length; 1) {
            //if (antiCrashCounter >= 8) {
            //    Wait(0.016);
            //    antiCrashCounter = 0;
            //}
            Any[] next = neighbors[i];
            if (useDualIndex) {
                define curDualIndex = getDualIndex(valKeys, current[1]);
                newCost = costsValues[curDualIndex[0]][curDualIndex[1]] + next[2];
                dualIndex = getDualIndex(valKeys, next[1]);
                check = dualIndex.Length == 0;
            } else
                check = !valKeys.Contains(next[1]);
            if (check) {
                if (useDualIndex) {
                    i1 = valKeys.Length - 1;
                    if (CountOf(valKeys[i1]) == 1000) {
                        i1++;
                    }
                    i2 = CountOf(valKeys[i1]);
                    valKeys[i1][i2] = next[1];
                    costsValues[i1][i2] = newCost;
                    //if (next[3] != 0) 
                    //    parentsValues[i1][i2] = next[3]; 
                    //else 
                    parentsValues[i1][i2] = current;
                } else {
                    if (valKeys.Length == 1000) {
                        useDualIndex = true;
                        valKeys = [valKeys];
                        costsValues = [costsValues];
                        parentsValues = [parentsValues];
                        i1 = 1;
                        i2 = 0;
                        valKeys[i1][i2] = next[1];
                        costsValues[i1][i2] = newCost;
                        parentsValues[i1][i2] = current;
                    } else {
                        i1 = valKeys.Length;
                        valKeys[i1] = next[1];
                        costsValues[i1] = newCost;
                        parentsValues[i1] = current;
                    }
                }
                if (useAStar)
                    next[2] = newCost + heuristic(lastPos, next[0] + next[1]);
                else
                    next[2] = heuristic(lastPos, next[0] + next[1]);
                priorityQueueAdd(frontier, next, listSorted);
                //uncomment this to enable debug visualization (1 more below)
                // CreateEffect(AllPlayers(), Effect.Sphere, Color.Orange, next[0] + next[1], 0.25, EffectRev.None);
                // vizEffects.ModAppend(LastCreatedEntity());
                // if (vizEffects.Length > 150) {
                //     DestroyEffect(vizEffects[0]);
                //     vizEffects.ModRemoveByIndex(0);
                // }
            } else {
                if (useDualIndex) {
                    dualIndex2 = getDualIndex(valKeys, next[1]);
                    i1 = dualIndex2[0];
                    i2 = dualIndex2[1];
                    costCheck = newCost < costsValues[i1][i2];
                } else {
                    i1 = valKeys.IndexOf(next[1]);
                    costCheck = newCost < costsValues[i1];
                }
                if (costCheck) {
                    if (useDualIndex) {
                        costsValues[i1][i2] = newCost;
                        //if (next[3] != 0) 
                        //    parentsValues[i1][i2] = next[3]; 
                        //else 
                        parentsValues[i1][i2] = current;
                    } else {
                        costsValues[i1] = newCost;
                        parentsValues[i1] = current;
                    }
                    if (useAStar)
                        next[2] = newCost + heuristic(lastPos, next[0] + next[1]);
                    else
                        next[2] = heuristic(lastPos, next[0] + next[1]);
                    priorityQueueAdd(frontier, next, listSorted);
                    //uncomment this to enable debug visualization
                    // CreateEffect(AllPlayers(), Effect.Sphere, Color.Orange, next[0] + next[1], 0.25, EffectRev.None);
                    // vizEffects.ModAppend(LastCreatedEntity());
                    // if (vizEffects.Length > 150) {
                    //     DestroyEffect(vizEffects[0]);
                    //     vizEffects.ModRemoveByIndex(0);
                    // }
                }
            }
            if (useDualIndex)
                antiCrashCounter += 5;
        }
    }
    return null;
}
